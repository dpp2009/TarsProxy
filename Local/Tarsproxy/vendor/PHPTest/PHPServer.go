// Package PHPTest comment
// This file was generated by tars2go 1.1.4
// Generated from PHPServer.tars
package PHPTest

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// SimpleStruct struct implement
type SimpleStruct struct {
	Id    int64 `json:"id"`
	Count int32 `json:"count"`
	Page  int16 `json:"page"`
}

func (st *SimpleStruct) ResetDefault() {
	st.Id = 0
	st.Count = 0
	st.Page = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *SimpleStruct) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Page, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SimpleStruct) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimpleStruct, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SimpleStruct) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Page, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SimpleStruct) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// OutStruct struct implement
type OutStruct struct {
	Id    int64  `json:"id"`
	Count int32  `json:"count"`
	Page  int16  `json:"page"`
	Str   string `json:"str"`
}

func (st *OutStruct) ResetDefault() {
	st.Id = 0
	st.Count = 0
	st.Page = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *OutStruct) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Page, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Str, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OutStruct) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OutStruct, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OutStruct) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Page, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Str, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OutStruct) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ComplicatedStruct struct implement
type ComplicatedStruct struct {
	Ss  []SimpleStruct          `json:"ss"`
	Rs  SimpleStruct            `json:"rs"`
	Mss map[string]SimpleStruct `json:"mss"`
	Str string                  `json:"str"`
}

func (st *ComplicatedStruct) ResetDefault() {
	st.Rs.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ComplicatedStruct) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Ss = make([]SimpleStruct, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Ss[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = st.Rs.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return err
	}

	st.Mss = make(map[string]SimpleStruct)
	for i1, e1 := int32(0), length; i1 < e1; i1++ {
		var k1 string
		var v1 SimpleStruct

		err = _is.Read_string(&k1, 0, false)
		if err != nil {
			return err
		}

		err = v1.ReadBlock(_is, 1, false)
		if err != nil {
			return err
		}

		st.Mss[k1] = v1
	}

	err = _is.Read_string(&st.Str, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ComplicatedStruct) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ComplicatedStruct, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ComplicatedStruct) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Ss)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ss {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Rs.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Mss)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Mss {

		err = _os.Write_string(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Str, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ComplicatedStruct) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LotofTags struct implement
type LotofTags struct {
	Id    int64                   `json:"id"`
	Count int32                   `json:"count"`
	Page  int16                   `json:"page"`
	Str   string                  `json:"str"`
	Ss    []SimpleStruct          `json:"ss"`
	Rs    SimpleStruct            `json:"rs"`
	Mss   map[string]SimpleStruct `json:"mss"`
}

func (st *LotofTags) ResetDefault() {
	st.Id = 0
	st.Count = 0
	st.Page = 0
	st.Rs.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *LotofTags) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Page, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Str, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Ss = make([]SimpleStruct, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Ss[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = st.Rs.ReadBlock(_is, 5, true)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 6, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return err
	}

	st.Mss = make(map[string]SimpleStruct)
	for i1, e1 := int32(0), length; i1 < e1; i1++ {
		var k1 string
		var v1 SimpleStruct

		err = _is.Read_string(&k1, 0, false)
		if err != nil {
			return err
		}

		err = v1.ReadBlock(_is, 1, false)
		if err != nil {
			return err
		}

		st.Mss[k1] = v1
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LotofTags) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LotofTags, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LotofTags) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Page, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Str, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Ss)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ss {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Rs.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Mss)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Mss {

		err = _os.Write_string(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LotofTags) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CommonInParam struct implement
type CommonInParam struct {
	AppId     int32  `json:"appId"`
	AreaId    int32  `json:"areaId"`
	YwGuid    int64  `json:"ywGuid"`
	UserType  int32  `json:"userType"`
	UserIp    string `json:"userIp"`
	DeviceUid string `json:"deviceUid"`
	ServerIp  string `json:"serverIp"`
	YwSession string `json:"ywSession"`
	Qimei     string `json:"qimei"`
}

func (st *CommonInParam) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *CommonInParam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.AppId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.AreaId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.YwGuid, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.UserType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UserIp, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeviceUid, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ServerIp, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.YwSession, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Qimei, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CommonInParam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CommonInParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CommonInParam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.AppId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.AreaId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.YwGuid, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.UserType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UserIp, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeviceUid, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ServerIp, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.YwSession, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Qimei, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CommonInParam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CommonResult struct implement
type CommonResult struct {
	Code    int32  `json:"code"`
	Message string `json:"message"`
}

func (st *CommonResult) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *CommonResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CommonResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CommonResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CommonResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CommonResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ActivityInfo struct implement
type ActivityInfo struct {
	ActivityId int64  `json:"activityId"`
	Title      string `json:"title"`
	StartTime  int64  `json:"startTime"`
	EndTime    int64  `json:"endTime"`
}

func (st *ActivityInfo) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ActivityInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.ActivityId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.StartTime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.EndTime, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ActivityInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ActivityInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ActivityInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.ActivityId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.StartTime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.EndTime, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ActivityInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}
